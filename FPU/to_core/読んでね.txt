

fadd, fsubの分割数を1増やしました。(NSTAGEで言うと1→2になりました)
fdivの大数/大数に対応しました。(一部、答えがinfとなるべきところで0になったりがあります。)
不要ですが、fmulのInfの掛け算に対応しました。


以下は1st Coreまでの内容です。

FPU.vに1st Coreのための各モジュールを結合しました。

module内の.vファイル全てを一緒に入れてください。

testはtest/test_FPU.svを使ってください。注意点としては、sqrtに負の値を入れると変な値になります。




以下はMandelbrotのときの内容です。

使い方の参考に、testを置いておきました。

◎実装にあたってのFPUモジュールの解釈

・(使う側) x1, x2に計算したい値を入れて、ctlで演算を選択し、enに1を入れる。次のクロックではen=0にする。
・(FPU) 計算が完了しているクロックになったらyに計算結果を代入。readyビットを立てる。次のクロックではready=0にする。
・(使う側) readyを監視して、ready=1のときの出力のyをキャッチする。

◎注意点

・もらったFPU.vと、countの開始値が1だけ違います。
　が、外から使う上ではreadyビットを見てもらえれば十分なので、気にしないでも大丈夫だと思います。

・feq, fleは出力が1 bitなので、FPU.vからの出力は上方向に0埋めしています。
　具体的に言うと、y[31:1]=31'b0で、y[0]が答えになっています。
　むしろMSBに入れたほうが都合が良いかもしれないので、応相談かもしれません。

・計算結果が出る前に次の値を入れたりするとバグるかもしれません。(faddとfmulなど、演算が違っても)
　クロックをしっかり分けられていれば、答えだけ取り出す分には基本的に正答が出ると思いますが、
　それでも「何の計算の結果だか分からなくなる」「答えが出るタイミングが同時になると、流石にバグる」などがあるので
　答えが出るまでは(readyビットが立ったことを確認するまでは)きっちりストールした方が安全です。