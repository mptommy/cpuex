コンパイラ実験第一回レポート
情報化学科3年　村山浩理（05201028）

解いた問題は問一。min-caml全体をそのまま圧縮したときに容量が1MBを大幅に超えたため、min-rtディレクトリおよびPowerPCやSPARC用のディレクトリは削除してある。

問一
ビルド方法
    トップディレクトリでmakeすることによってmin-camlができる。

実装の説明
    今回手を加えたファイルはmain.mlのみである。
    今回実装したうち、主要なものはprint_syntax_tとprint_knormal_tの二つである。
    まず、print_syntax_tはSyntax.t型の中間状態の出力を標準出力に表示するための関数である。
    Syntax.t型の出力を引数にとり、この出力の木構造を先頭からパターンマッチングによって再帰的に解析し、それぞれのパターンによってコンストラクタと値を適切なインデントによって木構造がわかりやすくなるように表示するようにした。
    print_syntax_t内で、使われている関数のうち私が実装したものはprint_id、print_id_list、print_id_t、print_id_t_list、put_tabである。前から順にId.tを表示するための関数、Id.tのリストを表示するための関数、Id.tとType.tの組を表示するための関数、Id.tとType.tの組のリストを表示するための関数、適切なインデントを表示するための関数である。
    改行に関してはprint_syntax_t内で行うようにした。
    インデントを表示するための関数put_tabでは、参照型の変数count_LRで今木のどの程度の深さの位置にいるのかを保存し、この木の深さ分スペースを表示することにした。tabでないのは環境によって表示崩れしてしまう場合があったためである。実装は以下のようになっている。
        let put_tab () = 
            let rec put c =
                if (c != 0) then (Printf.printf " "; put (c - 1)) else ()
            in put !count_LR
    以上によってSyntax.t型の入力を与えられればこれを表示できるようになったため、最後にコンパイラのメインルーチンに組み込むためにparse_print関数を実装した。
    parse_print関数は引数としてParser.expに与えるに引数のほかに中間状態の表示を行うかを入力する用の整数型引数をとるようになっており、これを0にすると中間状態の表示はせずにパーサの結果を出力するようにし、0以外になっているときには中間状態の表示も行うようにした。
    次に、print_knormal_tはKnormal.t型の中間状態の出力を入力として受け取り、中間状態の木構造がわかりやすいように表示する処理を行う関数であり、基本的な処理はprint_syntax_tと同じである。
    print_syntax_tとの違いは、Syntax.t型とKnormal.t型の違いによるパターンマッチおよび処理の違いのみである。
    この関数に関してもput_tab関数を用いて適切にインデント表示するようになっている。また、この関数をメインルーチンに組み込むための関数normal_printは関数lexbufでK正規化、α変換および各種最適化による中間出力を表示するかどうかを整数型の引数で選択できるようにした。

実行結果
    中間状態の表示をすべて有効にした上でtest/fib.mlをコンパイルした。
    以下、700行程実行結果。
free variable print_int assumed as external
iteration 1000
iteration 999
directly applying fib.10
directly applying fib.10
directly applying fib.10
eliminating closure(s) fib.10
register allocation: may take some time (up to a few minutes, depending on the size of functions)
generating assembly...


print syntax tree

LETREC {
 name = fib args = n
 body =
 IF
  LE
   VAR n
   INT 1
  VAR n
  ADD
   APP
    VAR fib
    SUB
     VAR n
     INT 1
   APP
    VAR fib
    SUB
     VAR n
     INT 2
 }
 APP
  VAR print_int
  APP
   VAR fib
   INT 30


print KNormal result

LETREC {
 name = fib args = n
 body =
 LET
  Ti3
  INT 1
  IFLE
   n
   Ti3
   VAR n
   LET
    Ti6
    LET
     Ti5
     LET
      Ti4
      INT 1
      SUB
       n
       Ti4
     APP
      fib
      Ti5
    LET
     Ti9
     LET
      Ti8
      LET
       Ti7
       INT 2
       SUB
        n
        Ti7
      APP
       fib
       Ti8
     ADD
      Ti6
      Ti9
 }
 LET
  Ti2
  LET
   Ti1
   INT 30
   APP
    fib
    Ti1
  EXTFUNAPP
   print_int
   Ti2


print Alpha result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti6.15
    LET
     Ti5.19
     LET
      Ti4.20
      INT 1
      SUB
       n.11
       Ti4.20
     APP
      fib.10
      Ti5.19
    LET
     Ti9.16
     LET
      Ti8.17
      LET
       Ti7.18
       INT 2
       SUB
        n.11
        Ti7.18
      APP
       fib.10
       Ti8.17
     ADD
      Ti6.15
      Ti9.16
 }
 LET
  Ti2.12
  LET
   Ti1.13
   INT 30
   APP
    fib.10
    Ti1.13
  EXTFUNAPP
   print_int
   Ti2.12


print Beta result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti6.15
    LET
     Ti5.19
     LET
      Ti4.20
      INT 1
      SUB
       n.11
       Ti4.20
     APP
      fib.10
      Ti5.19
    LET
     Ti9.16
     LET
      Ti8.17
      LET
       Ti7.18
       INT 2
       SUB
        n.11
        Ti7.18
      APP
       fib.10
       Ti8.17
     ADD
      Ti6.15
      Ti9.16
 }
 LET
  Ti2.12
  LET
   Ti1.13
   INT 30
   APP
    fib.10
    Ti1.13
  EXTFUNAPP
   print_int
   Ti2.12


print Assoc result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print Inline result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print ConstFold result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print Elim result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print Beta result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print Assoc result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print Inline result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print ConstFold result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12


print Elim result

LETREC {
 name = fib.10 args = n.11
 body =
 LET
  Ti3.14
  INT 1
  IFLE
   n.11
   Ti3.14
   VAR n.11
   LET
    Ti4.20
    INT 1
    LET
     Ti5.19
     SUB
      n.11
      Ti4.20
     LET
      Ti6.15
      APP
       fib.10
       Ti5.19
      LET
       Ti7.18
       INT 2
       LET
        Ti8.17
        SUB
         n.11
         Ti7.18
        LET
         Ti9.16
         APP
          fib.10
          Ti8.17
         ADD
          Ti6.15
          Ti9.16
 }
 LET
  Ti1.13
  INT 30
  LET
   Ti2.12
   APP
    fib.10
    Ti1.13
   EXTFUNAPP
    print_int
    Ti2.12

考察
    実装が全て終わった後で考えたことであるが、木における今いる深さを表すのにわざわざcount_LRという参照型の変数を用いる必要はなく、各関数内にこれを表す用の引数を一つ設けるだけでよかった。